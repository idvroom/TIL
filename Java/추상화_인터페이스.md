# 추상화

### 추상 클래스, 추상 메소드

- 인스턴스 생성 불가
- 추상 메소드를 포함하고 있을뿐 일반 클래스와 동일
- 추상 메소드는 구현부가 없고 자식에서 무조건 재정의

```java
public class MainAbstract {
    public static void main(String[] args) {
        AbstractSub sub = new AbstractTarget();
        sub.childOverride();
        sub.get();

        //이런식으로 추상 메소드를 오버라이드 해서는 사용가능
        AbstractSub sub2 = new AbstractSub() {
            @Override
            void childOverride() {
                System.out.println("case2");
            }
        };
        sub2.childOverride();
    }
}

public class AbstractTarget extends AbstractSub{
    @Override
    void childOverride() {
        System.out.println("재정의 필수");
    }
}

public abstract class AbstractSub {
    public void get() {
        System.out.println("get Test");
    }

    abstract void childOverride();
}
```

- 협업 시 메소드를 놓치는 경우 방지<br>
  2번은 move 호출 시 부모 메소드가 호출이 된다.
- 협업 시 메소드명 통일

```java
public abstract class AbstractSub {
    abstract void move();
}

public class AbstractTarget extends AbstractSub{
    @Override
    void move() {
        System.out.println("move1");
    }
}

//move 호출 시 부모 메소드가 호출이 된다
public class ExtendsSub {
    void move() {
        System.out.println("parent move");
    }
}

public class AbstractTarget2 extends ExtendsSub{
}

```

- 다형성, 업캐스팅

```java
public class AbstractTarget extends AbstractSub{
    @Override
    void move() {
        System.out.println("AbstractTarget");
    }
}

public class AbstractTarget2 extends AbstractSub{
    @Override
    void move() {
        System.out.println("AbstractTarget2");
    }
}

public static void main(String[] args) {
    AbstractSub sub = new AbstractTarget();
    sub.move();

    AbstractSub sub2 = new AbstractTarget2();
    sub2.move();
}

//결과
//AbstractTarget
//AbstractTarget2
```

[좋은 글](https://limkydev.tistory.com/188)

### 인터페이스

- 인터페이스는 다중 implements 가능
- 추상메소드: 재정의 필수
- 디폴트메소드: 구현된 걸 쓰거나 재정의해서 사용하거나
  운영되던 시스템에 추가하면 유용하다. 추상 메소드로 추가 시 모든 implements에 추가 해야함
- 인터페이스 자체는 인스턴스화 불가

```java
public interface IntfSub {
    int MAX_VALUE = 100; //public static final 생략 가능

    void methodTest(); //public abstract 생략 가능

    //디폴트 java8
    default void defaultTest() {
        System.out.println("defaultTest");
    }

    //정적 java8
    static void staticTest() {
        System.out.println("staticTest");
    }
}

//다중
// public class IntfImpl implements IntfSub, IntfSub2{
public class IntfImpl implements IntfSub{
    @Override
    public void methodTest() {

    }

    public void defaultTest() {
        System.out.println("child defaultTest");
    }
}


IntfImpl impl = new IntfImpl();
impl.defaultTest();

//child defaultTest
```

- 인터페이스 일부 구현 시 추상클래스로 생성

```java
interface IntfTest {
    void methodTest();
    void abstractTest();
}

public abstract class IntfImpl2 implements IntfTest{
    @Override
    public void methodTest() {
    }
}

class TestCalss extends IntfImpl2 {
    @Override
    public void abstractTest() {
      //여기서 구현
    }
}
```

- 인터페이스는 다중 상속이 가능

```java
interface Intf1 {
    void method1();
}

interface Intf2 {
    void method2();
}

//인터페이스 2개 상속
interface MainIntf extends Intf1, Intf2 {
}

//여기서 구현
public class IntfImpl2 implements MainIntf{
    @Override
    public void method1() {
    }

    @Override
    public void method2() {
    }
}
```

[참고](https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4Interface%EC%9D%98-%EC%A0%95%EC%84%9D-%ED%83%84%ED%83%84%ED%95%98%EA%B2%8C-%EA%B0%9C%EB%85%90-%EC%A0%95%EB%A6%AC)

- 추상화, 인터페이스 차이..

- 다중 상속 불가
- 상속 제한은 없다

```java
public class BasicClassExtends extends BasicClass, BasicClass2 {
    //불가
}
public class BasicClassExtends extends BasicClass {
    //가능
}

//가능
public class class1 extends BasicClass {}
public class class2 extends BasicClass {}
public class class3 extends BasicClass {}
```

- 자식 클래스 실행 시 부모, 자식의 생성자가 부모 -> 자식순으로 실행된다.
- 자식에서 부모 생성자 호출은 super()로 가능하다.
- 부모 클래스의 초기화가 필요하기 때문에 자식 클래스 생성자 첫 줄에서 super()가 호출되어야 하며, 없을 경우 컴파일러가 자동으로 생성해준다.

```java
public class BasicClass {
    public BasicClass() {
        System.out.println("BasicClass 생성자");
    }
}

public class BasicClassExtends extends BasicClass {
    public BasicClassExtends(){
        System.out.println("BasicClassExtends 생성자");
    }
}

//결과
//BasicClass 생성자
//BasicClassExtends 생성자

//부모 클래스에 매개변수가 있는 생성자가 있는 경우
public class BasicClass {
    public BasicClass(String name){
        System.out.println("BasicClass 생성자: " + name);
    }
}

public class BasicClassExtends extends BasicClass {
    public BasicClassExtends(){
        super("이름");
    }
}
//결과
//BasicClass 생성자: 이름
```

- 자식에서 부모의 필드나 메소드를 호출 할 때 super를 사용한다.
- 이름이 같은 경우 부모 클래스의 값을 호출한다.
- 둘 다 있다면 자식 우선, super로 부모 호출 가능
- static은 상속이 되지 않는다.
  - 메모리에 올라간 걸 호출한다.
  - staticMethod는 자식에서 Override는 되지 않는다.
  - 자식에도 staticMethod가 있다면 부모의 staticMethod가 hide 된다고 한다.
    <br>[참고 링크](https://jinyoungchoi95.tistory.com/16)

```java
public class BasicClass {
    int age = 50;
    int parentAge = 60;
    static int staticNum = 10;

    public void method(){
        System.out.println("parent method");
    }

    public static void staticMethod(){
        System.out.println("staticMethod");
    }
}

public class BasicClassExtends extends BasicClass {
    int age = 10;
    int childAge = 20;

    @Override
    public void method(){
        System.out.println("child method");
    }

    public static void staticMethod(){
        System.out.println("child staticMethod");
    }

    public void callTest(){
        System.out.println(super.age); //50
        System.out.println(this.age); //10
        System.out.println(age); //10

        System.out.println(childAge); //20
        System.out.println(this.childAge); //20

        System.out.println(super.parentAge); //60
        System.out.println(this.parentAge); //60
        System.out.println(parentAge); //60

        method(); //child method
        this.method(); //child method
        super.method(); //parent method

        staticMethod(); //child staticMethod
    }

}
```

- override 재정의를 했을 경우 자식만 실행된다.
- final을 사용하면 override가 되지 않는다.

```java
public class BasicClass {
  public void overrideTest(){
    System.out.println("parent overrideTest");
  }
}
public class BasicClassExtends extends BasicClass {
  public void callTest(){
    overrideTest();
    //-> child overrideTest
  }

  public void overrideTest(){
    System.out.println("child overrideTest");
  }
}

test commit
```
